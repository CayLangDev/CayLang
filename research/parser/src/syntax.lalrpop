use crate::ast::{Expr, Literal, stripstr, Ident, LabelledList, UnlabelledList, Pair};
use std::str::FromStr;

grammar;

pub Main: Expr = Expr;

// expression is any series (space seperated) of closed expressions
Expr: Expr = ClosedExpr+ => Expr::ExprList(<>);

// a closed expression is any independent expression, it's value is fully encapsulated in
// its node in the ast.
// i.e. "1" is exactly 1, "(f)" is exactly the function f with no arguments applied, "(f a)" is exactly f with the argument a applied
// on the other hand: "f a" is the function f with a applied as an argument, it may have further arguments next to it that will be applied, and so is not a closed expression.
ClosedExpr: Expr = {
    "(" <BasicExpr+> ")" => Expr::ExprList(<>),
    BasicExpr
}

// basic expression is any single identifier, literal or compound literal.
BasicExpr: Expr = {
    Ident => Expr::Ident(<>),
    Literal => Expr::Literal(<>),
    LabelledList => Expr::LabelledList(<>),
    UnlabelledList => Expr::UnlabelledList(<>)
}

// "{" "}" refers to an empty unlabelled list
// currently no way to write an empty labelled list
UnlabelledList: UnlabelledList = "{" <Comma<Expr>> "}";
LabelledList: LabelledList = "{" <CommaM<Pair>> "}";
Pair: Pair = <i:Ident> ":" <e:Expr> => Pair(<>);
// these should probably be considered literals
// or part of a new CompoundLiteral enum

// secret sauce
Ident: Ident = r"[a-zA-Z]+[a-zA-Z0-9_]*" => String::from(<>);

Literal: Literal = {
    r#""(?:[^\\"]|(?:\\"))*""# => Literal::String(stripstr(<>, 1)), // arbitrary characters between "", except " which must be preceded by \.
    r#"r"(?:[^\\"]|(?:\\"))*""# => Literal::Regex(stripstr(<>, 2)), // could add regex for checking regex, rn same as string.
    r#"p"(?:[^\\"]|(?:\\"))*""# => Literal::Path(stripstr(<>, 2)), // can add path character set checking here from old fold regex, rn same as string.
    r"[0-9]+(?:\.[0-9]*)?" => Literal::Numeric(f64::from_str(<>).unwrap()) // should add distinct integer and floating point type, currently all floats.
}


// Comma Seperated Capture Rule of T, taken from LALRPOP documentation.
Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// Comma Seperated Capture Rule of T, must have atleast one T, modified from above.
CommaM<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T> => { // (2)
            v.push(e);
            v
        }
};

