use crate::ast::{Expr, Literal, stripstr, Ident, LabelledList, UnlabelledList, Pair};
use std::str::FromStr;

grammar;

pub Main: Expr = expr;

expr: Expr = basic_expr+  => Expr::ExprList(<>);

basic_expr: Expr = {
    ident => Expr::Ident(<>),
    literal => Expr::Literal(<>),
    labl_list => Expr::LabelledList(<>),
    unlabl_list => Expr::UnlabelledList(<>)
}

unlabl_list: UnlabelledList = "{" <Comma<expr>> "}";
labl_list: LabelledList = "{" <CommaM<pair>> "}";
pair: Pair = <i:ident> ":" <e:expr> => Pair(<>);

ident: Ident = r"[a-zA-Z]+[a-zA-Z0-9_]*" => String::from(<>);

literal: Literal = {
    r#""(?:[^\\"]|(?:\\"))*""# => Literal::String(stripstr(<>, 1)),
    r#"r"(?:[^\\"]|(?:\\"))*""# => Literal::Regex(stripstr(<>, 2)),
    r#"p"(?:[^\\"]|(?:\\"))*""# => Literal::Path(stripstr(<>, 2)),
    r"[0-9]+(?:\.[0-9]*)?" => Literal::Numeric(f64::from_str(<>).unwrap())
}


// Comma Seperated Capture Rule of T, taken from LALRPOP documentation.
Comma<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T?> => match e { // (2)
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// Comma Seperated Capture Rule of T, must have atleast one T, taken from LALRPOP documentation.
CommaM<T>: Vec<T> = { // (1)
    <mut v:(<T> ",")*> <e:T> => { // (2)
            v.push(e);
            v
        }
};

